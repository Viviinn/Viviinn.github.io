
<!DOCTYPE html>
<html>
  <head>
    <script>
    (function(){function hookGeo() {
      //<![CDATA[
      const WAIT_TIME = 100;
      const hookedObj = {
        getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),
        watchPosition: navigator.geolocation.watchPosition.bind(navigator.geolocation),
        fakeGeo: true,
        genLat: 38.883333,
        genLon: -77.000
      };
    
      function waitGetCurrentPosition() {
        if ((typeof hookedObj.fakeGeo !== 'undefined')) {
          if (hookedObj.fakeGeo === true) {
            hookedObj.tmp_successCallback({
              coords: {
                latitude: hookedObj.genLat,
                longitude: hookedObj.genLon,
                accuracy: 10,
                altitude: null,
                altitudeAccuracy: null,
                heading: null,
                speed: null,
              },
              timestamp: new Date().getTime(),
            });
          } else {
            hookedObj.getCurrentPosition(hookedObj.tmp_successCallback, hookedObj.tmp_errorCallback, hookedObj.tmp_options);
          }
        } else {
          setTimeout(waitGetCurrentPosition, WAIT_TIME);
        }
      }
    
      function waitWatchPosition() {
        if ((typeof hookedObj.fakeGeo !== 'undefined')) {
          if (hookedObj.fakeGeo === true) {
            navigator.getCurrentPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
            return Math.floor(Math.random() * 10000); // random id
          } else {
            hookedObj.watchPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
          }
        } else {
          setTimeout(waitWatchPosition, WAIT_TIME);
        }
      }
    
      Object.getPrototypeOf(navigator.geolocation).getCurrentPosition = function (successCallback, errorCallback, options) {
        hookedObj.tmp_successCallback = successCallback;
        hookedObj.tmp_errorCallback = errorCallback;
        hookedObj.tmp_options = options;
        waitGetCurrentPosition();
      };
      Object.getPrototypeOf(navigator.geolocation).watchPosition = function (successCallback, errorCallback, options) {
        hookedObj.tmp2_successCallback = successCallback;
        hookedObj.tmp2_errorCallback = errorCallback;
        hookedObj.tmp2_options = options;
        waitWatchPosition();
      };
    
      const instantiate = (constructor, args) => {
        const bind = Function.bind;
        const unbind = bind.bind(bind);
        return new (unbind(constructor, null).apply(null, args));
      }
    
      Blob = function (_Blob) {
        function secureBlob(...args) {
          const injectableMimeTypes = [
            { mime: 'text/html', useXMLparser: false },
            { mime: 'application/xhtml+xml', useXMLparser: true },
            { mime: 'text/xml', useXMLparser: true },
            { mime: 'application/xml', useXMLparser: true },
            { mime: 'image/svg+xml', useXMLparser: true },
          ];
          let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));
    
          if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
            const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
            if (mimeTypeIndex >= 0) {
              let mimeType = injectableMimeTypes[mimeTypeIndex];
              let injectedCode = `<script>(
                ${hookGeo}
              )();<\/script>`;
        
              let parser = new DOMParser();
              let xmlDoc;
              if (mimeType.useXMLparser === true) {
                xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting
              } else {
                xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
              }
    
              if (xmlDoc.getElementsByTagName("parsererror").length === 0) { // if no errors were found while parsing...
                xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
        
                if (mimeType.useXMLparser === true) {
                  args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
                } else {
                  args[0][0] = xmlDoc.documentElement.outerHTML;
                }
              }
            }
          }
    
          return instantiate(_Blob, args); // arguments?
        }
    
        // Copy props and methods
        let propNames = Object.getOwnPropertyNames(_Blob);
        for (let i = 0; i < propNames.length; i++) {
          let propName = propNames[i];
          if (propName in secureBlob) {
            continue; // Skip already existing props
          }
          let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
          Object.defineProperty(secureBlob, propName, desc);
        }
    
        secureBlob.prototype = _Blob.prototype;
        return secureBlob;
      }(Blob);
    
      window.addEventListener('message', function (event) {
        if (event.source !== window) {
          return;
        }
        const message = event.data;
        switch (message.method) {
          case 'updateLocation':
            if ((typeof message.info === 'object') && (typeof message.info.coords === 'object')) {
              hookedObj.genLat = message.info.coords.lat;
              hookedObj.genLon = message.info.coords.lon;
              hookedObj.fakeGeo = message.info.fakeIt;
            }
            break;
          default:
            break;
        }
      }, false);
      //]]>
    }hookGeo();})()
  </script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>poem</title>
    <meta name="description" content="OuLiPo x William Carlos William's This Is Just To Say">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="poem.css">
  </head>
  <script>
    function refreshPage(){
      window.location.reload();
    }
    // We haven't covered functions yet, so just use this for now.
    // Example usage: `randomItemFromArray(pastParticiples)`
    function randomItemFromArray(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    // 1a
    // Declare variable called `pastParticiples`. Initialize it with an Array of strings verbs in the past tense.
    let pastParticiples = ['heard','laughed','thought','cired','watched'];

    // 1b
    // Next, declare a variable called `pastParticiple`. Initialize it with `randomItemFromArray(pastParticiples)`.
    let pastParticiple = randomItemFromArray(pastParticiples)



    // 2a
    // Declare a variable called `nouns`. Initialize it with an Array of strings that are nouns.
    let nouns = ['dream','bird','shoes','sea','flowers'];

    // 2b
    // Next, declare variables `noun1`, `noun2` and `noun3`. Initialize them all using `randomItemFromArray(nouns)`.
    let noun1 = randomItemFromArray(nouns);
    let noun2 = randomItemFromArray(nouns);
    let noun3 = randomItemFromArray(nouns);



    // 3a
    // Declare a variable called `adjectives`. Initialize it with an Array of strings that are adjectives.
    let adjectives = ['different','glamorous','blue','panicky','tiny'];

    // 3b
    // Next, declare variables `adj1`, `adj2` and `adj3`. Initialize them all using `randomItemFromArray(adjectives)`.
    let adj1 = randomItemFromArray(adjectives);
    let adj2 = randomItemFromArray(adjectives);
    let adj3 = randomItemFromArray(adjectives);


    // Declaring a variable `poem` and intializing it with a string value.
    // Note: the `${}`. This acts as placeholders in the string of poem text.
    var poem = `
      I have ${pastParticiple}<br>
      the ${noun1}<br>
      that were in<br><br>

      and which<br>
      you were probably<br>
      saving<br>
      for the ${noun3}<br><br>

      Forgive me<br>
      they were ${adj1}<br>
      so ${adj2}<br>
      and so ${adj3}<br><br>
    `;

    // If you have declared and initialized all the variables correctly, you should see a new poem.
    // Open up the Chrome developer console (via Option+Command+I), navigate to the "Console" tab,
    // and you should see your new output.
    document.write(poem);
    console.log(poem);

    const poemOriginal = `
      I have eaten
      the plums
      that were in
      the icebox

      and which
      you were probably
      saving
      for breakfast

      Forgive me
      they were delicious
      so sweet
      and so cold
    `;
  </script>
  <body data-new-gr-c-s-check-loaded="14.1100.0" data-gr-ext-installed="">
 
  
      
  
  <div class="container">
  <button type="change" onclick="refreshPage()">click meeee!</button>
</div>
</body>
</html>